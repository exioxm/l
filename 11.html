<!DOCTYPE html>
<html>
<head>
    <title>JS Tower Defense</title>
    <style>
        body { background: #222; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        canvas { background: #333; border: 4px solid #555; cursor: crosshair; }
        .stats { margin: 10px; font-size: 20px; display: flex; gap: 20px; }
        .controls { color: #aaa; font-size: 14px; }
    </style>
</head>
<body>

    <div class="stats">
        <span>üí∞ Gold: <span id="gold">100</span></span>
        <span>‚ù§Ô∏è Lives: <span id="lives">10</span></span>
        <span>üåä Wave: <span id="wave">1</span></span>
    </div>

    <canvas id="gameCanvas" width="600" height="400"></canvas>

    <div class="controls">Click to place Tower (Cost: 50 Gold)</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game State
let gold = 100;
let lives = 10;
let wave = 1;
let frames = 0;

const enemies = [];
const towers = [];
const projectiles = [];

// The Path (X, Y nodes)
const path = [{x: 0, y: 200}, {x: 150, y: 200}, {x: 150, y: 100}, {x: 450, y: 100}, {x: 450, y: 300}, {x: 600, y: 300}];

class Enemy {
    constructor() {
        this.x = path[0].x;
        this.y = path[0].y;
        this.health = 10 + (wave * 5);
        this.maxHealth = this.health;
        this.speed = 1 + (wave * 0.1);
        this.pathIndex = 0;
        this.reward = 10;
    }

    update() {
        let target = path[this.pathIndex + 1];
        if (target) {
            let dx = target.x - this.x;
            let dy = target.y - this.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < this.speed) {
                this.pathIndex++;
            } else {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }
        } else {
            lives--;
            this.health = 0; // Remove from game
        }
    }

    draw() {
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
        ctx.fill();
        // Health bar
        ctx.fillStyle = '#000';
        ctx.fillRect(this.x - 10, this.y - 15, 20, 3);
        ctx.fillStyle = '#f00';
        ctx.fillRect(this.x - 10, this.y - 15, (this.health / this.maxHealth) * 20, 3);
    }
}

class Tower {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.range = 120;
        this.fireRate = 30; // Frames between shots
        this.timer = 0;
    }

    draw() {
        ctx.fillStyle = '#3498db';
        ctx.fillRect(this.x - 15, this.y - 15, 30, 30);
        // Range indicator (subtle)
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
        ctx.stroke();
    }

    update() {
        this.timer++;
        if (this.timer >= this.fireRate) {
            // Find nearest enemy
            let nearest = null;
            let minDist = this.range;

            enemies.forEach(enemy => {
                let dx = enemy.x - this.x;
                let dy = enemy.y - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            });

            if (nearest) {
                projectiles.push(new Projectile(this.x, this.y, nearest));
                this.timer = 0;
            }
        }
    }
}

class Projectile {
    constructor(x, y, target) {
        this.x = x;
        this.y = y;
        this.target = target;
        this.speed = 5;
        this.dead = false;
    }

    update() {
        let dx = this.target.x - this.x;
        let dy = this.target.y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < 5) {
            this.target.health -= 5;
            this.dead = true;
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
    }

    draw() {
        ctx.fillStyle = 'yellow';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Handle Tower Placement
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (gold >= 50) {
        towers.push(new Tower(x, y));
        gold -= 50;
    }
});

function gameLoop() {
    frames++;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw Path
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 30;
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    path.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.stroke();

    // Wave Management
    if (frames % 100 === 0) {
        enemies.push(new Enemy());
    }
    if (frames % 1000 === 0) {
        wave++;
    }

    // Update & Draw
    towers.forEach(t => { t.update(); t.draw(); });
    
    for (let i = projectiles.length - 1; i >= 0; i--) {
        projectiles[i].update();
        projectiles[i].draw();
        if (projectiles[i].dead || projectiles[i].target.health <= 0) projectiles.splice(i, 1);
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].update();
        enemies[i].draw();
        if (enemies[i].health <= 0) {
            if (enemies[i].health <= 0 && enemies[i].pathIndex < path.length - 1) gold += enemies[i].reward;
            enemies.splice(i, 1);
        }
    }

    // UI
    document.getElementById('gold').innerText = gold;
    document.getElementById('lives').innerText = lives;
    document.getElementById('wave').innerText = wave;

    if (lives > 0) requestAnimationFrame(gameLoop);
    else {
        ctx.fillStyle = 'white';
        ctx.font = '40px Arial';
        ctx.fillText("GAME OVER", 180, 200);
    }
}

gameLoop();
</script>
</body>
</html>
