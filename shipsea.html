<!DOCTYPE html>
<html>
<head>
    <title>Mk48.io - Full Prototype 2026</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; color: #0f0; }
        canvas { display: block; }
        #ui { position: absolute; top: 15px; left: 15px; pointer-events: none; z-index: 10; }
        /* Minimap Styling */
        #minimap-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 150px; height: 150px;
            background: rgba(0, 40, 80, 0.7);
            border: 2px solid #0f0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>HULL: <span id="hp">100</span>% | XP: <span id="xp">0</span></div>
        <div>SENSOR: <span id="sensorMode">PASSIVE</span> (Z)</div>
    </div>
    <div id="minimap-container">
        <canvas id="minimapCanvas" width="150" height="150"></canvas>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mCanvas = document.getElementById('minimapCanvas');
const mCtx = mCanvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- World Config ---
const WORLD_SIZE = 4000;
let player = { x: 2000, y: 2000, angle: 0, speed: 2.5, curSpeed: 0, hp: 100, xp: 0, sensor: 500, activeSonar: false };
let enemies = [], projectiles = [], particles = [];
let keys = {};

// --- Particle System ---
class Particle {
    constructor(x, y, vx, vy, color, life) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.color = color; this.life = life; this.maxLife = life;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
}

// --- Logic ---
function update() {
    // Movement
    if (keys['w']) player.curSpeed = Math.min(player.curSpeed + 0.05, player.speed);
    else player.curSpeed *= 0.98;
    if (keys['a']) player.angle -= 0.04;
    if (keys['d']) player.angle += 0.04;
    
    player.x = Math.max(0, Math.min(WORLD_SIZE, player.x + Math.cos(player.angle) * player.curSpeed));
    player.y = Math.max(0, Math.min(WORLD_SIZE, player.y + Math.sin(player.angle) * player.curSpeed));

    // Particle Wakes
    if (player.curSpeed > 0.5 && Math.random() > 0.5) {
        particles.push(new Particle(player.x, player.y, (Math.random()-0.5), (Math.random()-0.5), '#fff', 30));
    }
    particles.forEach((p, i) => { p.update(); if (p.life <= 0) particles.splice(i, 1); });

    // Enemy Spawning
    if (enemies.length < 8) {
        enemies.push({ x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, id: Math.random() });
    }
}

function drawMinimap() {
    mCtx.clearRect(0, 0, mCanvas.width, mCanvas.height);
    const scale = mCanvas.width / WORLD_SIZE;

    // Draw Player dot
    mCtx.fillStyle = '#0f0';
    mCtx.beginPath();
    mCtx.arc(player.x * scale, player.y * scale, 3, 0, Math.PI*2);
    mCtx.fill();

    // Draw Detected Enemies
    const viewDist = player.activeSonar ? player.sensor * 2 : player.sensor;
    enemies.forEach(en => {
        if (Math.hypot(player.x - en.x, player.y - en.y) < viewDist) {
            mCtx.fillStyle = 'red';
            mCtx.fillRect(en.x * scale - 1, en.y * scale - 1, 3, 3);
        }
    });
}

function draw() {
    ctx.fillStyle = '#00142b';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const camX = player.x - canvas.width/2;
    const camY = player.y - canvas.height/2;

    // Grid Lines (Sea Floor)
    ctx.strokeStyle = '#002a55';
    for(let i=0; i<WORLD_SIZE; i+=200) {
        ctx.beginPath(); ctx.moveTo(i-camX, 0-camY); ctx.lineTo(i-camX, WORLD_SIZE-camY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0-camX, i-camY); ctx.lineTo(WORLD_SIZE-camX, i-camY); ctx.stroke();
    }

    // Particles
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life/p.maxLife;
        ctx.fillRect(p.x - camX, p.y - camY, 2, 2);
    });
    ctx.globalAlpha = 1;

    // Player
    ctx.save();
    ctx.translate(player.x - camX, player.y - camY);
    ctx.rotate(player.angle);
    ctx.fillStyle = '#0f0';
    ctx.beginPath(); ctx.moveTo(20,0); ctx.lineTo(-12,-8); ctx.lineTo(-12,8); ctx.fill();
    ctx.restore();

    drawMinimap();
    requestAnimationFrame(() => { update(); draw(); });
}

window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (e.key.toLowerCase() === 'z') {
        player.activeSonar = !player.activeSonar;
        document.getElementById('sensorMode').innerText = player.activeSonar ? "ACTIVE" : "PASSIVE";
    }
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

draw();
</script>
</body>
</html>
