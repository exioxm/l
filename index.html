<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nitro Racer Pro</title>
    <style>
        body { margin: 0; background: #222; overflow: hidden; font-family: 'Courier New', Courier, monospace; display: flex; justify-content: center; align-items: center; height: 100vh; }
        #game-wrap { position: relative; border: 4px solid #444; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        canvas { display: block; background: #333; cursor: crosshair; }
        #hud { position: absolute; top: 10px; left: 10px; color: #0f0; text-shadow: 1px 1px #000; pointer-events: none; }
        .stat { font-size: 18px; margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="game-wrap">
        <div id="hud">
            <div class="stat">SCORE: <span id="score">0</span></div>
            <div class="stat">SPEED: <span id="speed">0</span> MPH</div>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

<script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const scoreElement = document.getElementById("score");
    const speedElement = document.getElementById("speed");

    canvas.width = 360;
    canvas.height = 600;

    let score = 0;
    let gameSpeed = 5;
    let gameRunning = true;
    let roadOffset = 0;
    let mouseX = canvas.width / 2;

    const player = { x: 155, y: 480, w: 50, h: 90, color: "#ff3e3e" };
    let enemies = [];

    // Controls: Track mouse/touch for steering
    canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left - player.w / 2;
    });

    canvas.addEventListener("touchmove", (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.touches[0].clientX - rect.left - player.w / 2;
        e.preventDefault();
    }, {passive: false});

    function spawnEnemy() {
        if (Math.random() < 0.02 + (score / 5000)) {
            const lanes = [40, 130, 220, 280];
            const laneX = lanes[Math.floor(Math.random() * lanes.length)];
            enemies.push({
                x: laneX, y: -100, w: 50, h: 90, 
                speed: gameSpeed + (Math.random() * 2),
                color: `hsl(${Math.random() * 360}, 70%, 50%)`
            });
        }
    }

    function drawCar(x, y, w, h, color, isPlayer) {
        // Main Body
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
        
        // Windows
        ctx.fillStyle = "#333";
        ctx.fillRect(x + 5, y + 15, w - 10, 20); // Front windshield
        ctx.fillRect(x + 5, y + 60, w - 10, 15); // Back window

        // Tires
        ctx.fillStyle = "#000";
        ctx.fillRect(x - 5, y + 10, 10, 20);
        ctx.fillRect(x + w - 5, y + 10, 10, 20);
        ctx.fillRect(x - 5, y + 60, 10, 20);
        ctx.fillRect(x + w - 5, y + 60, 10, 20);

        // Headlights / Tail-lights
        ctx.fillStyle = isPlayer ? "white" : "red";
        ctx.fillRect(x + 5, y, 10, 5);
        ctx.fillRect(x + w - 15, y, 10, 5);
    }

    function update() {
        if (!gameRunning) return;

        // Smooth steering
        player.x += (mouseX - player.x) * 0.15;
        if (player.x < 10) player.x = 10;
        if (player.x > canvas.width - player.w - 10) player.x = canvas.width - player.w - 10;

        // Road movement
        roadOffset += gameSpeed;
        if (roadOffset > 100) roadOffset = 0;

        // Difficulty scaling
        gameSpeed = 5 + Math.floor(score / 20);
        speedElement.innerText = Math.floor(gameSpeed * 10);

        enemies.forEach((obs, index) => {
            obs.y += obs.speed;

            // Collision check
            if (player.x < obs.x + obs.w && player.x + player.w > obs.x &&
                player.y < obs.y + obs.h && player.y + player.h > obs.y) {
                gameRunning = false;
                setTimeout(() => {
                    alert("WRECKED! Final Score: " + score);
                    location.reload();
                }, 10);
            }

            if (obs.y > canvas.height) {
                enemies.splice(index, 1);
                score += 10;
                scoreElement.innerText = score;
            }
        });
        spawnEnemy();
    }

    function draw() {
        // Draw Road
        ctx.fillStyle = "#444";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Road Lines (Scrolling effect)
        ctx.strokeStyle = "#fff";
        ctx.setLineDash([40, 60]);
        ctx.lineDashOffset = -roadOffset;
        ctx.lineWidth = 6;
        
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, 0);
        ctx.lineTo(canvas.width / 2, canvas.height);
        ctx.stroke();

        // Draw Entities
        drawCar(player.x, player.y, player.w, player.h, player.color, true);
        enemies.forEach(obs => drawCar(obs.x, obs.y, obs.w, obs.h, obs.color, false));

        update();
        requestAnimationFrame(draw);
    }

    draw();
</script>
</body>
</html>
